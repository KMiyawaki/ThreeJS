<!DOCTYPE html>

<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Scene</title>
    <script type="text/javascript" src="../js/three.min.js"></script>
    <script type="text/javascript" src="../js/OrbitControls.js"></script>
    <script type="text/javascript" src="../js/myThree2020.js"></script>
    <script type="text/javascript" src="../js/myGameCharacter.js"></script>
    <script type="text/javascript" src="../js/myMaze.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/common.css">
</head>

<body>
    <div id="screen" class="screen">
        <!-- ↓↓↓work31の追記・修正場所↓↓↓ -->
        <div id="glView" style="position: relative;height: 40%;">
            <!--textarea id="debugText" rows="8" cols="20" class="debugText" style="display: none;">Debug output</textarea> デバッグ用表示を無くしたいときはこちらを有効にする。-->
            <textarea id="debugText" rows="8" cols="20" class="debugText">Debug output</textarea>
        </div>
        <div id="info" style="position: relative;height: 35%;background-color:coral;">
            <div id="status" class="status" style="width: 20%;">主人公ステータス</div>
            <textarea id="message" class="message" style="left: 20%;width: 78%">メッセージウィンドウ</textarea>
        </div>
        <div id="controller" style="position: relative;height: 25%;background-color: chocolate;">
            <div id="up" class="arrowButton"
                style="top: 5%; left: 16%; background-image:url(../assets/gray_arrow.png);">
            </div>
            <div id="down" class="arrowButton"
                style="top: 65%; left: 16%; background-image:url(../assets/gray_arrow.png); transform: rotate(180deg)">
            </div>
            <div id="left" class="arrowButton"
                style="top: 35%; left: 3%; background-image:url(../assets/gray_arrow.png); transform: rotate(-90deg)">
            </div>
            <div id="right" class="arrowButton"
                style="top: 35%; left: 29%; background-image:url(../assets/gray_arrow.png); transform: rotate(90deg)">
            </div>
            <button id="gu" type="button" class="pushButton" style="width: 13%;top: 30%; right: 33%;" value="0">
                グ
            </button>
            <button id="cho" type="button" class="pushButton" style="width: 13%;top: 30%; right: 18%;" value="1">
                チ
            </button>
            <button id="pa"" type=" button" class="pushButton" style="width: 13%;top: 30%; right: 3%;" value="2">
                パ
            </button>
        </div>
        <!-- ↑↑↑work31の追記・修正場所↑↑↑ -->
    </div>
    <script type="text/javascript">
        function init() {
            /* 主要な HTML 要素の取得 */
            const divScreen = document.getElementById("screen");
            const divGlView = document.getElementById("glView");
            const taDebugText = document.getElementById("debugText");

            /* デバッグ用の出力 */
            const AUTO_SCROLL_DEBUG = true; // taDebugText を常に最新の行までスクロールさせるかどうか。
            taDebugText.value = ("ViewPort: " + window.innerWidth + "," + window.innerHeight + "\n");

            /* THREE.js の初期化 */
            const [scene, camera, renderer, clock, axes] = mylib2020.initThreeInElement(divGlView);

            /* 平面の生成 */
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshPhongMaterial({ color: 0xCCFFCC }));
            plane.rotateX(THREE.Math.degToRad(-90)); /* X 軸中心に90度回転 */
            plane.receiveShadow = true; /* 他の物体の影が落ちる */
            scene.add(plane);

            /* 球体の生成 */
            const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.5, 20, 20), new THREE.MeshPhongMaterial({ color: 0x0000FF, wireframe: false }));
            sphere.position.set(3, 3, 3); /* 座標(3,3,3)に移動 */
            sphere.castShadow = true; /* 他の物体に影を落とす */
            scene.add(sphere);

            /* 立方体の生成 */
            const cubeGeometry = new THREE.BoxGeometry(3, 3, 3); /* Geometry の生成を分けて書くこともできる */
            /* ↓↓↓work31の追記・修正場所↓↓↓ */
            const loader = new THREE.TextureLoader(); /* テクスチャをロードするための道具 */
            const mapTexture = loader.load("../assets/downloads/ReflectingTheLava.png"); /* 指定されたURLからテクスチャをロード */
            const bumpTexture = loader.load("../assets/downloads/RockWall_orFloor_height.png"); /* バンプマップ用テクスチャ */
            const cubeMaterial = new THREE.MeshPhongMaterial({ map: mapTexture, bumpMap: bumpTexture, bumpScale: 0.2 }); /* bumpMap:バンプテクスチャ、bumpScale:バンプマップの深さ */
            /* ↑↑↑work31の追記・修正場所↑↑↑ */
            const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.castShadow = true; /* 他の物体に影を落とす */
            cube.receiveShadow = true; /* 他の物体から影が落ちる */
            scene.add(cube);

            /* スポットライトの生成 */
            const spotLight = new THREE.SpotLight(0xFFFFFF, 1); /* 色は白、強さは 1.0 */
            spotLight.angle = THREE.Math.degToRad(45); /* 光源位置から画角90度の円錐状に光を発する */
            spotLight.penumbra = 0.6; /* 半影をどの程度生じさせるか。 */
            spotLight.castShadow = true; /* 他の物体に影を落とす */
            scene.add(spotLight); /* ライト本体と */
            scene.add(spotLight.target); /* 照射ターゲットもシーンに追加する必要がある */

            /* カメラ等の位置調整 */
            /* ↓↓↓work31の追記・修正場所↓↓↓ */
            cube.position.set(0, 1.5, 9);
            sphere.position.set(0, 1.7, 0);
            sphere.castShadow = false;
            camera.position.set(0, 0, 0);
            camera.lookAt(0, 0, 1);
            spotLight.position.set(0, 0.3, -0.5);
            spotLight.target.position.set(0, -2, 2);
            scene.remove(camera);
            scene.remove(spotLight);
            scene.remove(spotLight.target);
            sphere.add(camera);
            sphere.add(spotLight);
            sphere.add(spotLight.target);
            sphere.position.set(3, 1.7, 3);
            scene.remove(cube);
            const blocks = [];
            const WIDTH = 5;
            const HEIGHT = 5;
            let index = 0;
            for (let z = 0; z < HEIGHT; z++) {
                for (let x = 0; x < WIDTH; x++) {
                    let cellType = MyMazeTestData[index];
                    if (cellType == 1) {
                        const tmp = new THREE.Mesh(cubeGeometry, cubeMaterial);
                        tmp.position.set(x * 3, 1.5, z * 3);
                        scene.add(tmp);
                        blocks.push(tmp);
                    }
                    index++;
                }
            }
            /* ↑↑↑work31の追記・修正場所↑↑↑ */

            /* ↓↓↓work31の追記・修正場所↓↓↓ */
            function onPushButtonClicked() {
                taDebugText.value += this.id + ":Pushed. value=" + this.value + "\n";
            }
            let elems = document.getElementsByClassName("pushButton");
            for (let e of elems) {
                e.addEventListener("click", onPushButtonClicked);
            }
            elems = document.getElementsByClassName("arrowButton");
            const arrows = {};
            for (let e of elems) {
                arrows[e.id] = new mylib2020.ArrowButton(e, "url(../assets/red_arrow.png)");
            }
            /* ↑↑↑work31の追記・修正場所↑↑↑ */

            /* アニメーションのための描画更新処理 */
            /* ↓↓↓work31の追記・修正場所↓↓↓ */
            const LINEAR = 3;
            const ANGULAR = THREE.Math.degToRad(60);
            const ENCOUNT = 0.01;
            let monster = null;
            const taMessage = document.getElementById("message");
            function renderFrame() {
                const deltaTime = clock.getDelta(); /* 前フレームからの経過時間。物体の移動に使う。 */
                const ran = Math.random();
                let enc = false;
                if (monster == null) {
                    /* 迷路の移動に関する処理 */
                    if (arrows["up"].isPressed()) {
                        // taDebugText.value += "up\n";
                        if (mylib2020.checkCollision(sphere, blocks, mylib2020.FORWARD) == false) {
                            sphere.translateOnAxis(mylib2020.FORWARD, LINEAR * deltaTime);
                            enc = (ran < ENCOUNT);
                        }
                    }
                    if (arrows["down"].isPressed()) {
                        // taDebugText.value += "down\n";
                        if (mylib2020.checkCollision(sphere, blocks, mylib2020.BACK) == false) {
                            sphere.translateOnAxis(mylib2020.BACK, LINEAR * deltaTime);
                            enc = (ran < ENCOUNT);
                        }
                    }
                    if (arrows["left"].isPressed()) {
                        // taDebugText.value += "left\n";
                        sphere.rotateY(ANGULAR * deltaTime);
                    }
                    if (arrows["right"].isPressed()) {
                        // taDebugText.value += "right\n";
                        sphere.rotateY(-ANGULAR * deltaTime);
                    }
                }
                if (enc) {
                    taDebugText.value += "Encount!!\n";
                    taMessage.value = "敵と遭遇した\n";
                    monster = new MyGameCharacter("モンスター", "../assets/downloads/red-dragon-1549047184nu3.png");
                    monster.show(divGlView);
                }
                /* ↑↑↑work31の追記・修正場所↑↑↑ */
                renderer.render(scene, camera);
                requestAnimationFrame(renderFrame);
                if (AUTO_SCROLL_DEBUG) {
                    taDebugText.scrollTop = taDebugText.scrollHeight;
                }
            }
            renderFrame();

            /* 画面サイズ変更時の処理 */
            window.addEventListener('resize', function () {
                taDebugText.value += ("ViewPort: " + window.innerWidth + "," + window.innerHeight + "\n");
                const glViewSize = divGlView.getBoundingClientRect();
                renderer.setSize(glViewSize.width, glViewSize.height);
                camera.aspect = glViewSize.width / glViewSize.height;
                camera.updateProjectionMatrix();
            });
        }
        window.addEventListener('load', init);
    </script>
</body>